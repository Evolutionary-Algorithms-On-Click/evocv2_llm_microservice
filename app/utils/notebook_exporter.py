"""Utility to export notebooks as single Python files for testing."""

from typing import Optional
import logging
from pathlib import Path

from app.models import NotebookStructure

logger = logging.getLogger(__name__)


class NotebookExporter:
    """Export notebooks to various formats."""

    @staticmethod
    def to_python_script(
        notebook: NotebookStructure,
        output_path: Optional[str] = None,
        include_comments: bool = True
    ) -> str:
        """
        Convert notebook to a single executable Python script.

        Args:
            notebook: The NotebookStructure to export
            output_path: Optional path to save the file. If None, returns string only
            include_comments: Whether to include cell separators as comments

        Returns:
            The complete Python script as a string
        """
        logger.info("Exporting notebook to Python script")

        script_lines = []

        # Add header
        if include_comments:
            script_lines.append('"""')
            script_lines.append("DEAP Evolutionary Algorithm")
            script_lines.append("Generated by EVOC DEAP Agent")
            script_lines.append("")
            script_lines.append("This script combines all 12 cells into a single executable file.")
            script_lines.append('"""')
            script_lines.append("")

        # Process each cell
        for i, cell in enumerate(notebook.cells):
            if cell.cell_type != "code":
                continue

            # Add cell separator comment
            if include_comments:
                cell_name = cell.cell_name or f"Cell {i}"
                script_lines.append("")
                script_lines.append(f"# {'=' * 70}")
                script_lines.append(f"# Cell {i}: {cell_name}")
                script_lines.append(f"# {'=' * 70}")
                script_lines.append("")

            # Add cell source code
            source = cell.source.strip()
            if source:
                script_lines.append(source)

        # Join all lines
        script = "\n".join(script_lines)

        # Save to file if path provided
        if output_path:
            output_file = Path(output_path)
            output_file.parent.mkdir(parents=True, exist_ok=True)
            output_file.write_text(script, encoding="utf-8")
            logger.info(f"Saved Python script to {output_path}")

        return script

    @staticmethod
    def to_ipynb(notebook: NotebookStructure, output_path: str):
        """
        Export notebook to Jupyter .ipynb format.

        Args:
            notebook: The NotebookStructure to export
            output_path: Path to save the .ipynb file
        """
        import json

        logger.info(f"Exporting notebook to Jupyter format: {output_path}")

        # Build Jupyter notebook structure
        ipynb_data = {
            "cells": [],
            "metadata": notebook.metadata or {
                "kernelspec": {
                    "display_name": "Python 3",
                    "language": "python",
                    "name": "python3"
                },
                "language_info": {
                    "name": "python",
                    "version": "3.8.0"
                }
            },
            "nbformat": 4,
            "nbformat_minor": 4
        }

        # Convert each cell
        for cell in notebook.cells:
            ipynb_cell = {
                "cell_type": cell.cell_type,
                "metadata": cell.metadata or {},
                "source": cell.source.split("\n")
            }

            # Add cell name to metadata if present
            if cell.cell_name:
                ipynb_cell["metadata"]["cell_name"] = cell.cell_name

            if cell.cell_type == "code":
                ipynb_cell["execution_count"] = cell.execution_count
                ipynb_cell["outputs"] = []

            ipynb_data["cells"].append(ipynb_cell)

        # Save to file
        output_file = Path(output_path)
        output_file.parent.mkdir(parents=True, exist_ok=True)

        with output_file.open("w", encoding="utf-8") as f:
            json.dump(ipynb_data, f, indent=2, ensure_ascii=False)

        logger.info(f"Successfully exported to {output_path}")


def export_for_testing(
    notebook: NotebookStructure,
    base_filename: str,
    output_dir: str = "./test_outputs"
) -> dict:
    """
    Export notebook in multiple formats for testing.

    Args:
        notebook: The notebook to export
        base_filename: Base name for output files (without extension)
        output_dir: Directory to save outputs

    Returns:
        Dictionary with paths to exported files
    """
    exporter = NotebookExporter()
    output_dir_path = Path(output_dir)
    output_dir_path.mkdir(parents=True, exist_ok=True)

    results = {}

    # Export as Python script
    py_path = output_dir_path / f"{base_filename}.py"
    script = exporter.to_python_script(notebook, str(py_path), include_comments=True)
    results["python_script"] = str(py_path)
    results["script_content"] = script

    # Export as Jupyter notebook
    ipynb_path = output_dir_path / f"{base_filename}.ipynb"
    exporter.to_ipynb(notebook, str(ipynb_path))
    results["jupyter_notebook"] = str(ipynb_path)

    logger.info(f"Exported notebook to {len(results)} formats in {output_dir}")

    return results


# Mock testing function
def mock_test_execution(script_content: str) -> dict:
    """
    Mock function to simulate testing the generated code.

    In a real implementation, this would execute the script and capture results.

    Args:
        script_content: The Python script to test

    Returns:
        Dictionary with test results
    """
    results = {
        "syntax_valid": False,
        "imports_ok": False,
        "has_evolution_loop": False,
        "line_count": 0,
        "errors": []
    }

    try:
        # Check syntax by compiling
        compile(script_content, "<string>", "exec")
        results["syntax_valid"] = True
    except SyntaxError as e:
        results["errors"].append(f"Syntax error: {e}")

    # Simple content checks
    results["imports_ok"] = "from deap import" in script_content
    results["has_evolution_loop"] = any(
        keyword in script_content
        for keyword in ["eaSimple", "eaMuPlusLambda", "for gen in range"]
    )
    results["line_count"] = len(script_content.split("\n"))

    return results
